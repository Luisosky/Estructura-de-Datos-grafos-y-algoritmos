<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Algorithms</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/graphlib/2.1.8/graphlib.min.js"></script>
</head>
<body>
    <button id="run-bellman-ford">Run Bellman-Ford</button>
    <button id="run-kruskal">Run Kruskal</button>
    <button id="run-dijkstra">Run Dijkstra</button>
    <button id="run-yen">Run Yen's K-Shortest Paths</button>

    <script>
        const graph = new graphlib.Graph();

        document.getElementById('run-bellman-ford').addEventListener('click', () => {
            let source = prompt("Ingrese el ID del nodo fuente:");
            let target = prompt("Ingrese el ID del nodo destino:");
            console.log("Ejecutando Bellman-Ford desde", source, "a", target);  // Depuración

            if (source && target && graph.hasNode(source) && graph.hasNode(target)) {
                let result = bellmanFordAlgorithm(graph, source, target);
                if (result.error) {
                    alert(result.error);  // Mostrar el mensaje de error si hay un ciclo negativo
                } else {
                    if (result.path.length === 0) {
                        alert("No hay un camino disponible entre los nodos especificados.");
                    } else {
                        alert(`Camino más corto: ${result.path.join(' -> ')} con distancia total: ${result.distance}`);
                    }
                }
            } else {
                alert("Verifica que los nodos existen.");
            }
        });

        document.getElementById('run-kruskal').addEventListener('click', () => {
            let result = kruskalAlgoritmo(graph);
            if (result.error) {
                alert(result.error);  // Depurar
            } else {
                let mstEdges = result.edges.map(edge => `${edge.v} - ${edge.w} (Peso: ${edge.weight})`);
                alert(`Árbol de expansión mínima:\n${mstEdges.join('\n')}`);
            }
        });

        document.getElementById('run-dijkstra').addEventListener('click', () => {
            let source = prompt("Ingrese el ID del nodo fuente:");
            let target = prompt("Ingrese el ID del nodo destino:");
            console.log("Ejecutando Dijkstra desde", source, "a", target);  // Depuración

            if (source && target && graph.hasNode(source) && graph.hasNode(target)) {
                let result = dijkstraPath(source, target);
                if (result.length === 0) {
                    alert("No hay un camino disponible entre los nodos especificados.");
                } else {
                    alert(`Camino más corto: ${result.join(' -> ')} con distancia total: ${calculatePathCost(result)}`);
                }
            } else {
                alert("Verifica que los nodos existen.");
            }
        });

        document.getElementById('run-yen').addEventListener('click', () => {
            let source = prompt("Ingrese el ID del nodo fuente:");
            let target = prompt("Ingrese el ID del nodo destino:");
            let k = parseInt(prompt("Ingrese el número de caminos más cortos a encontrar:"));
            console.log("Ejecutando Yen desde", source, "a", target, "para", k, "caminos");  // Depuración

            if (source && target && !isNaN(k) && graph.hasNode(source) && graph.hasNode(target)) {
                let result = yenKShortestPaths(source, target, k);
                if (result.length === 0) {
                    alert("No hay caminos disponibles entre los nodos especificados.");
                } else {
                    result.forEach((path, i) => {
                        alert(`Camino ${i + 1}: ${path.join(' -> ')} con distancia total: ${calculatePathCost(path)}`);
                    });
                }
            } else {
                alert("Verifica que los nodos existen y que los datos son válidos.");
            }
        });

        // Implementación del algoritmo Bellman-Ford
        function bellmanFordAlgorithm(graph, source, target) {
            const distances = {};
            const predecessors = {};

            // Inicializar las distancias y predecesores
            graph.nodes().forEach(node => {
                distances[node] = Infinity;
                predecessors[node] = null;
            });
            distances[source] = 0;

            // Relajación de todas las aristas |V| - 1 veces
            for (let i = 0; i < graph.nodeCount() - 1; i++) {
                graph.edges().forEach(edge => {
                    const u = edge.v;
                    const v = edge.w;
                    const weight = graph.edge(u, v);
                    if (distances[u] !== Infinity && distances[u] + weight < distances[v]) {
                        distances[v] = distances[u] + weight;
                        predecessors[v] = u;
                    }
                });
            }

            // Comprobar ciclos de peso negativo
            for (const edge of graph.edges()) {
                const u = edge.v;
                const v = edge.w;
                const weight = graph.edge(u, v);
                if (distances[u] !== Infinity && distances[u] + weight < distances[v]) {
                    return { error: "El grafo contiene un ciclo de peso negativo." };
                }
            }

            // Reconstruir el camino desde el destino al origen
            const path = [];
            let current = target;
            while (current !== null) {
                path.push(current);
                current = predecessors[current];
            }
            path.reverse();

            // Si no se pudo llegar al destino desde el origen, devolver un camino vacío
            return {
                path: distances[target] === Infinity ? [] : path,
                distance: distances[target]
            };
        }

        // Implementación del algoritmo Yen's K-Shortest Paths
        function yenKShortestPaths(source, target, k) {
            // Inicializar los caminos k y los candidatos
            let kPaths = [];
            let candidatos = [];
            
            // Camino más corto inicial usando Dijkstra
            let shortestPath = dijkstraPath(source, target);
            if (!shortestPath) return kPaths; // Si no hay un camino, retorna vacío
            kPaths.push(shortestPath);

            for (let i = 1; i < k; i++) {
                for (let j = 0; j < kPaths[i - 1].length - 1; j++) {
                    let spurNode = kPaths[i - 1][j];
                    let rootPath = kPaths[i - 1].slice(0, j + 1);

                    // Crear una copia temporal del grafo
                    let tempGraph = new graphlib.Graph({ directed: false });
                    cy.edges().forEach(edge => {
                        const sourceId = edge.data('source');
                        const targetId = edge.data('target');
                        const weight = edge.data('weight');
                        if (!rootPath.includes(sourceId) || !rootPath.includes(targetId)) {
                            tempGraph.setEdge(sourceId, targetId, weight);
                        }
                    });

                    // Remover aristas de caminos ya encontrados
                    kPaths.forEach(path => {
                        if (JSON.stringify(path.slice(0, j + 1)) === JSON.stringify(rootPath)) {
                            tempGraph.removeEdge(path[j], path[j + 1]);
                        }
                    });

                    // Calcular el camino a partir del spur node hasta el destino
                    let spurPath = dijkstraPathFromGraph(tempGraph, spurNode, target);
                    if (spurPath) {
                        let totalPath = rootPath.slice(0, -1).concat(spurPath);
                        let totalCost = calculatePathCost(totalPath);

                        // Agregar a candidatos
                        candidatos.push({ cost: totalCost, path: totalPath });
                    }
                }

                // Ordenar los candidatos por costo y añadir el camino con menor costo a kPaths
                if (candidatos.length > 0) {
                    candidatos.sort((a, b) => a.cost - b.cost);
                    let newPath = candidatos.shift().path;
                    kPaths.push(newPath);
                } else {
                    break;
                }
            }

            return kPaths;
        }

        // Función para encontrar el camino más corto con Dijkstra
        function dijkstraPath(source, target) {
            let path = graphlib.alg.dijkstra(graph, source, e => graph.edge(e));
            let result = [];
            let current = target;

            while (current !== source) {
                result.push(current);
                current = path[current].predecessor;
            }
            result.push(source);
            return result.reverse();
        }

        // Función para calcular el costo total de un camino
        function calculatePathCost(path) {
            let cost = 0;
            for (let i = 0; i < path.length - 1; i++) {
                let weight = graph.edge(path[i], path[i + 1]);
                if (weight !== undefined) {
                    cost += weight;
                } else {
                    return Infinity; // Si no hay una arista, el costo es infinito
                }
            }
            return cost;
        }
    </script>
</body>
</html>