<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grafos y algoritmos</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.21.1/cytoscape.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/graphlib/2.1.8/graphlib.min.js"></script>
    <style>
        #cy {
            width: 80%;
            height: 600px;
            display: inline-block;
        }
        #controls {
            width: 18%;
            display: inline-block;
            vertical-align: top;
        }
        button {
            display: block;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="add-node">Agregar Nodo</button>
        <button id="add-edge">Agregar Arista</button>
        <button id="run-dijkstra">Dijkstra</button>
        <button id="run-kruskal">Kruskal</button>
        <button id="run-bellman-ford">Bellman-Ford</button>
    </div>
    <div id="cy"></div>

    <script>
        let cy = cytoscape({
            container: document.getElementById('cy'),
            style: [
                {
                    selector: 'node',
                    style: {
                        'background-color': 'lightblue',
                        'label': 'data(id)'
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 3,
                        'line-color': 'gray',
                        'target-arrow-color': 'gray',
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'bezier',
                        'label': 'data(weight)'
                    }
                }
            ],
            elements: []
        });

        let graph = new graphlib.Graph({ directed: false });
        let nodeCount = 0;

        document.getElementById('añadir-nodo').addEventListener('click', () => {
            nodeCount++;
            let nodeId = `n${nodeCount}`;
            cy.add({
                group: 'nodes',
                data: { id: nodeId },
                position: { x: Math.random() * 600, y: Math.random() * 600 }
            });
            graph.setNode(nodeId);
            console.log("Nodo agregado:", nodeId);  // Depuración
            console.log("Estado del grafo:", graph);
        });

        document.getElementById('añadir-arista').addEventListener('click', () => {
            let source = prompt("Ingrese el ID del nodo fuente:");
            let target = prompt("Ingrese el ID del nodo destino:");
            let weight = parseFloat(prompt("Ingrese el peso de la arista:"));
            let color = prompt("Ingrese el color de la arista (por ejemplo, 'red', 'blue'):");

            if (source && target && !isNaN(weight) && color && graph.hasNode(source) && graph.hasNode(target)) {
                cy.add({
                    group: 'edges',
                    data: { id: `e${source}-${target}`, source: source, target: target, weight: weight },
                    style: { 'line-color': color, 'target-arrow-color': color }
                });
                graph.setEdge(source, target, weight);
                console.log("Arista agregada:", source, "->", target, "con peso", weight);  // Depuración
                console.log("Estado del grafo después de añadir arista:", graph);
            } else {
                alert("Verifica que los nodos existen y que los datos son válidos.");
            }
        });

        document.getElementById('run-kruskal').addEventListener('click', () => {
            console.log("Ejecutando Kruskal...");  // Depuración
            try {
                let mst = graphlib.alg.kruskal(graph);
                if (mst.length === 0) {
                    alert("No se pudo generar un árbol de expansión mínima. Verifica que el grafo es conexo.");
                } else {
                    let mstEdges = mst.map(edge => `${edge.v} - ${edge.w} (Peso: ${edge.weight})`);
                    alert(`Árbol de expansión mínima:\n${mstEdges.join('\n')}`);
                    console.log("Resultado de Kruskal:", mstEdges);  // Depuración
                }
            } catch (error) {
                console.error("Error en Kruskal:", error);
                alert("Hubo un error al ejecutar el algoritmo de Kruskal. Verifica la consola para más detalles.");
            }
        });

        document.getElementById('run-bellman-ford').addEventListener('click', () => {
            let source = prompt("Ingrese el ID del nodo fuente:");
            let target = prompt("Ingrese el ID del nodo destino:");
            console.log("Ejecutando Bellman-Ford desde", source, "a", target);  // Depuración

            if (source && target && graph.hasNode(source) && graph.hasNode(target)) {
                let result = bellmanFordAlgoritmo(graph, source, target);
                if (result.error) {
                    alert(result.error); 
                } else {
                    if (result.path.length === 0) {
                        alert("No hay un camino disponible entre los nodos especificados.");
                    } else {
                        alert(`Camino más corto: ${result.path.join(' -> ')} con distancia total: ${result.distance}`);
                    }
                }
            } else {
                alert("Verifica que los nodos existen.");
            }
        });

        function bellmanFordAlgoritmo(graph, source, target) {
            let distance = {};
            let predecessor = {};
            let nodes = graph.nodes();
            let edges = graph.edges();

            nodes.forEach(node => {
                distance[node] = node === source ? 0 : Infinity;
                predecessor[node] = null;
            });

            for (let i = 1; i < nodes.length; i++) {
                edges.forEach(edge => {
                    let sourceNode = edge.v;
                    let targetNode = edge.w;
                    let weight = graph.edge(edge);
                    if (distance[sourceNode] + weight < distance[targetNode]) {
                        distance[targetNode] = distance[sourceNode] + weight;
                        predecessor[targetNode] = sourceNode;
                    }
                });
            }

            edges.forEach(edge => {
                let sourceNode = edge.v;
                let targetNode = edge.w;
                let weight = graph.edge(edge);
                if (distance[sourceNode] + weight < distance[targetNode]) {
                    return { error: "El grafo contiene un ciclo negativo." };
                }
            });

            let path = [];
            let current = target;
            while (current) {
                path.unshift(current);
                current = predecessor[current];
            }

            return { path, distance: distance[target] };
        }
    </script>
</body>
</html>
